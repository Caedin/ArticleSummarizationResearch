import sysimport osimport reimport nltk.datafrom scipy import statsimport numpy as npfrom HTMLParser import HTMLParser# create a subclass and override the handler methodsclass MyHTMLParser(HTMLParser):	data_list = []	def handle_starttag(self, tag, attrs):		pass	def handle_endtag(self, tag):		pass	def handle_data(self, data):		self.data_list.append(str(data))	def clear_data(self):		self.data_list = []		parser = MyHTMLParser()'''Author: Keith DyerThis program will take the summaries generated by the Batch_Summarizer.py program and compare the automatically generated summaries to the human hand picked summaries in the DUC 2002 data sets.The summaries will be evaluated by word over lap count between the automatic summary and the human picked summary.'''def create_mod_table():	path = './MOD/2002/data/test/docs.with.sentence.breaks/'	mod_table = {}	for folder in os.listdir(path):		for file in os.listdir(path+folder):			with open(path+folder+'/'+file, 'rb') as input:				mod_table[file.strip()] = ''.join([k for k in input])		return mod_tabledef create_bon_table():	path = './BON/2002/data/test/docs.with.sentence.breaks/'	bon_table = {}	for folder in os.listdir(path):		for file in os.listdir(path+folder):			with open(path+folder+'/'+file, 'rb') as input:				bon_table[file.strip()] = ''.join([k for k in input])		return bon_table	def create_trs_table():	path = './TRS/2002/data/test/docs.with.sentence.breaks/'	trs_table = {}	for folder in os.listdir(path):		for file in os.listdir(path+folder):			with open(path+folder+'/'+file, 'rb') as input:				trs_table[file.strip()] = ''.join([k for k in input])		return trs_tabledef create_human_table():	path = './DUC/2002/data/test/summaries/summaries/'	human_table = {}	for folder in os.listdir(path):		for file in os.listdir(path+folder):			if file == 'perdocs':				with open(path+folder+'/'+file, 'rb') as input:					text = ''.join([x for x in input])								summaries = []				starts = [m.start() for m in re.finditer('<SUM', text)]				ends = [m.start() for m in re.finditer('</SUM>', text)]								for x in xrange(len(starts)):					summaries.append(text[starts[x]:ends[x]])								for x in summaries: 					doc_ref_loc = x.find('DOCREF="')+8					doc_ref_end = x[doc_ref_loc:].find('"')+doc_ref_loc					file_name = x[doc_ref_loc:doc_ref_end].strip()										data_loc = x.find('>')+1					summary = x[data_loc:]					human_table[file_name] = summary.strip()						return human_table	def create_optimal_table(human_table):	path = './DUC/2002/data/test/docs.with.sentence.breaks/'	optimal_table = {}	article_table = {}	for folder in os.listdir(path):		if '.tar' not in folder:			for article in os.listdir(path+'/'+folder):				parser.clear_data()								with open(path+'/'+folder+'/'+article, 'rb') as input:					text_local = ''.join([x for x in input])				text_local = text_local.replace('\n', ' ')				parser.feed(text_local)				text_local = ''.join([x for x in parser.data_list])				article_table[article[:-2]] = [x for x in parser.data_list]		for document in human_table:		article = article_table[document]		summary = human_table[document]				opt_set = []				for sentence in article:			string1 = sentence			string2 = summary						string1 = string1.split()			string2 = string2.split()						for x in xrange(len(string1)):				string1[x] = string1[x].strip()							for x in xrange(len(string2)):				string2[x] = string2[x].strip()					set1 = set(string1)			set2 = set(string2)						overlap = len(set1 & set2)						opt_set.append((overlap, sentence))				opt_set.sort(key = lambda x: x[0])		opt_set.reverse()		opt_set = opt_set[0:5]				optimal_table[document] = ''.join([x[1] for x in opt_set])	return optimal_table												def compute_overlap(table1, table2):	overlap_table = {}	for key in table1:		if key in table2:			string1 = table1[key]			string2 = table2[key]						string1 = string1.split()			string2 = string2.split()						for x in xrange(len(string1)):				string1[x] = string1[x].strip()							for x in xrange(len(string2)):				string2[x] = string2[x].strip()					set1 = set(string1)			set2 = set(string2)						overlap = len(set1 & set2)						overlap_table[key] = overlap	return overlap_tableif __name__ == '__main__':	'''	Idea: 		1) load MOD, TRS, BON summaries into a three hash tables, using the article ID as the key.		2) load the human picked summaries into a hash table, using the article ID as the key. (use perdoc files)		3) compute the overlap for each summary in MOD, TRS, BON with human picked.		4) Generate an output file for each method covering: average/doc, and each doc count.		5) compute paired t-test to see if how the methods compare statistically.	'''	mod_table = create_mod_table()	bon_table = create_bon_table()	trs_table = create_trs_table()	human_table = create_human_table()	opt_table = create_optimal_table(human_table)		mod_human_overlap = compute_overlap(mod_table, human_table)	bon_human_overlap = compute_overlap(bon_table, human_table)	trs_human_overlap = compute_overlap(trs_table, human_table)	opt_human_overlap = compute_overlap(opt_table, human_table)		m = sum([mod_human_overlap[x] for x in mod_human_overlap]) / float(len(mod_human_overlap))	b = sum([bon_human_overlap[x] for x in bon_human_overlap]) / float(len(bon_human_overlap))	t = sum([trs_human_overlap[x] for x in trs_human_overlap]) / float(len(trs_human_overlap))	o = sum([opt_human_overlap[x] for x in opt_human_overlap]) / float(len(opt_human_overlap))		m__t = stats.ttest_rel([mod_human_overlap[x] for x in mod_human_overlap], [trs_human_overlap[x] for x in trs_human_overlap])	b__t = stats.ttest_rel([bon_human_overlap[x] for x in bon_human_overlap], [trs_human_overlap[x] for x in trs_human_overlap])	b__m = stats.ttest_rel([bon_human_overlap[x] for x in bon_human_overlap], [mod_human_overlap[x] for x in mod_human_overlap])		print 'MOD ', 'Average Overlap: ', m, 'p-value vs TRS:', m__t[1]	print 'BON ', 'Average Overlap: ', b, 'p-value vs TRS:', b__t[1]	print 'TRS ', 'Average Overlap: ', t	print 'OPT ', 'Average Overlap: ', o	